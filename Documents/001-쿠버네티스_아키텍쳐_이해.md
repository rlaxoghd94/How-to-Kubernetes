# 1장: 쿠버네티스 아키텍쳐 이해

**쿠버네티스**: 컨테이너 기반 애플리케이션의 배포, 확장, 관리를 조율하는 플랫폼

## 쿠버네티스는 무엇인가

쿠버네티스는 계속 증가하고 있는 엄청난 수의 서비스와 기능이 포함된 플랫폼이다.

핵심 기능은 인프라 전체에 걸쳐 컨테이너에서 작업부하를 스케줄할 수 있는 능력이다.

- 스토리지 시스템 마운트

- 보안 배포

- 애플리케이션 상태 확인

- 애플리케이션 인스턴스 복제

- 수평적 포드 자동 스케일링

- 이름 지정과 검색

- 로드밸런싱(부하 균영 조정)

- 롤링 업데이트

- 리소스 모니터링

- 로그 액세스 및 수집

- 애플리케이션 디버깅

- 인증과 권한 부여

<br></br>

## 쿠버네티스가 아닌 것은 무엇인가

쿠버네티스는 **PaaS**(Platform as a Service)는 아니다. 원하는 서비스를 만들 때 시스템의 중요 사항을 일일이 구성할 필요가 없다. 대신 이런 사항을 쿠버네티스 위에 구축된 시스템이나 사용자에게 남겨 둔다. 예를 들면 다음과 같다.

- 쿠버네티스는 특정한 애플리케이션 유형이나 프레임워크를 요구하지 않는다

- 쿠버네티스는 특정한 프로그래밍 언어를 요구하지 않는다

- 쿠버네티스는 데이터베이스 또는 메시지 대기열을 제공하지 않는다

- 쿠버네티스는 앱과 서비스를 구분하지 않는다

- 쿠버네티스는 클릭 투 배포 서비스 시장을 가지고 있지 않다

- 쿠버네티스는 사용자가 자체 로깅과 모니터링, 경보 시스템을 선택할 수 있다

<br></br>

## 컨테이너 오케스트레이션 이해

쿠버네티스의 주요 임무는 컨테이너 오케스트레이션이다. 즉, 다양한 작업을 실행하는 모든 컨테이너가 물리 장치나 가상 머신에서 실행되도록 예약돼 있는지 확인한다. 그리고 배포 환경과 클러스터 설정의 제약 사항에 따라 컨테이너가 효율적으로 패키징돼야 한다. 또한 쿠버네티스는 실행 중인 모든 컨테이너를 모니터링하여 중지되거나 응답이 없거나 상태가 불량한 컨테이너를 교체한다.

### 컨테이너의 장점

- 애자일(민첩한) 애플리케이션 생성과 배포

- 지속적인 개발과 통합 및 배포

- 개발 및 운영 분리의 관심사

- 개발과 테스트, 운영 전반에 걸친 환경 일관성

- 클라우드와 OS 배포 이식성

- 애플리케이션 중심의 관리

- 느슨하게 결합하고 분산되며 탄력적이고 자율적인 마이크로서비스의 리소스 격리

- 리소스 활용성

<br></br>

## 쿠버네티스 개념

### 클러스터

클러스터는 쿠버네티스가 시스템을 구성하는 다양한 업무를 실행하는 데 사용하는 다수의 컴퓨터, 스토리지, 네트워크 리소스의 집합이다. 여러 개의 클러스터로 전체 시스템을 구성할 수 있다.

### 노드

노드는 단일 호스트로 물리 머신이거나 가상 머신일 수 있다. 노드는 포드를 실행시킨다. 각 쿠버네티스 노드는 kubelet과 kube proxy 등 여러 쿠버네티스 컴포넌트를 실행한다. 각각의 노드는 쿠버네티스 마스터에 의해 관리된다.

### 마스터

마스터는 쿠버네티스의 컨트롤 플레인으로 클러스터를 관리한다. 마스터는 API 서버, 스케줄러, 컨트롤러 매니저 등 여러 컴포넌트로 구성된다. 마스터는 클러스터 수준의 포드 스케줄링과 이벤트 처리를 담당한다. 모든 마스터 컴포넌트는 단일 호스트에 설정하는 것이 일반적이나, 고가용성 시나리오나 대규모 클러스터를 고려할 경우에는 마스터 이중화(redundancy)를 요구한다

### 포드

포드는 쿠버네티스의 작업 단위다. 포드에는 한 개 또는 여러 개의 컨테이너가 들어 있다. 동일한 시스템에서 실행되는 여러 포드는 항상 함께 스케줄링된다. 포드의 컨테이너들은 모두 동일한 IP 주소와 포트 공간을 가지고 있으며 로컬호스트를 사용하거나 표준 IPC를 사용해 서로 통신한다. 또는 포드의 모든 컨테이너는 포드를 호스팅하는 노드에 있는 공유 로컬 저장소에 접근이 가능하며, 공유 저장소는 각 컨테이너로 마운트될 수 있다.

포드 개념의 장점으로는:

- **투명성**: 포드 내부의 컨테이너를 인프라에 표시하면 인프라가 프로세스 관리와 리소스 모니터링 서비스를 컨테이너에 제공할 수 있다

- **소프트웨어 종속성 분리**: 개별 컨테이너의 버전 관리, 재구축, 재배포를 독립적으로 수행할 수 있다

- **사용 편의성**: 사용자는 자신의 프로세스 매니저를 실행할 필요가 없으며 시그널과 종료 코드 전파 등을 걱정하지 않아도 된다

- **효율성**: 인프라에 더 많은 역할을 부여해 컨테이너를 더 경량화할 수 있는 장점이 있다

포드는 서로 의존하며 목적을 달성하기 위해 동일한 호스트에서 협업해야 하는 밀접한 연관이 있는 컨테이너 그룹을 관리하기 위한 훌륭한 솔류션을 제공한다. 포드는 필요에 따라 버릴 수 있고 교체할 수 있는 일시적인 요소이며, 포드 저장소는 해당 포드와 함께 소멸된다. 각 포드는 **고유한 ID**를 가지며 필요에 따라 ID를 구별할 수 있다.

### 라벨

라벨은 키/값(key-value)쌍의 객체 집합이며 주로 포드를 그룹화할 때 사용한다. 라벨은 복제 컨트롤러, 복제 세트, 동적 개체 그룹에서 동작하고 그룹 구성원을 식별하는 서비스와 같은 여러 다른 관점에서 중요하다. 객체와 라벨 사이에는 N X N 관계가 있다. 따라서 각 개체는 여러 개의 라벨을 가질 수 있고 각 라벨도 여러 객체에 적용될 수 있다. 라벨 설계에는 제한 사항이 있다. 객체의 라벨은 반드시 고유한 키를 가져야 하며, 라벨 키는 반드시 엄격한 구문을 따라야 한다. 구문은 접두사와 이름, 두 부분으로 구성되며 접두사는 선택 사항이다. 접두사는 슬래시(/)로 이름과 구분되며 유효한 DNS 하위 도메인으로 구성되고 최대 253자까지 허용된다. 이름은 필수이며 최대 63자까지 허용된다. 이름은 문자나 숫자(a-zA-Z0-9)로 시작하고 끝나야 하며, 문자, 숫자, 점, 대시, 밑줄만 사용 가능하다. 값 항목에도 이름과 동일한 제약 사항이 적용된다. 라벨은 객체를 식별하는 데 사용하며 객체에 임의의 메타데이터를 연결하지 않는다.

### 애노테이션

애노테이션(Annotation)을 사용하면 임의의 메타데이터를 쿠버네티스 객체와 연결할 수 있다. 쿠버네티스는 애노테이션을 저장하고 메타데이터를 사용할 수 있게 한다. 라벨과 애노테이션의 차이는 애노테이션은 허용 가능한 문자나 크기에 엄격한 제한이 없다는 것이다.

### 라벨 설렉터

라벨 설렉터(Label selector)는 라벨을 기반으로 객체를 선택하며, 동등 기반 설렉터와 집합 기반 설렉터가 있다. 동등 기반(equality-based) 설렉터는 키 이름과 값을 지정하며 값에 따라 같음이나 다름을 나타내는 =(또는 ==)와 != 두 연산자를 사용한다.

```python
role = webserver
```

이 경우 라벨 키와 값을 가진 모든 객체가 선택된다.

라벨 설렉터는 복수 조건을 쉼표(,)로 구분할 수 있다.

```python
role = webserver, application != foo
```

집합 기반(set-based) 설렉터는 기능을 확장해 다양한 값을 기반으로 하여 객체를 선택한다.

```python
role in (webserver, backend)
```

### 복제 컨트롤러와 복제 세트

복제 컨트롤러(Replication controller)와 복제 세트(replica set)는 라벨 설렉터로 식별된 포드 그룹을 관리하고 특정 수만큼 항상 실행 중인지 확인한다. 복제 컨트롤러는 이름의 동일 여부로 구성원을 확인하는 반면에, 복제 세트는 집합 기반 선택을 사용한다는 것이 두 개념의 주요 차이점이다.

쿠버네티스는 복제 컨트롤러나 복제 세트에서 지정한 수의 포드가 항상 실행되도록 보장한다. 어떤 문제가 발생해 호스팅 노드나 포드의 수가 일정 수준 이하로 내려가면 쿠버테니스는 새로운 인스턴스를 시작한다. 사용자가 수동으로 새로운 포드를 시작해 지정한 수를 초과하면 복제 컨트롤러는 지정한 수를 유지하기 위해 추가된 포드만큼 기존에 동작 중인 포드를 정지시키므로 주의해야 한다.

복제 컨트롤러는 롤링 업데이트나 일회성 작업 실행과 같은 많은 업무 흐름의 중심에 있다. 쿠버네티스가 진화함에 따라 **배포**(deployment), **잡**(job), **데몬세트**(DaemonSet) 같은 전용 객체(오브젝트)를 통해 여러 작업 흐름들을 직접 지원할 수 있게 됐다.

### 서비스

서비스는 사용자나 다른 서비스에 특정 기능을 노출하는 데 사용된다. 서비스는 특정 라벨을 가지고 있는 포드를 선택해 서비스로 묶을 수 있다. 또한 외부 리소스에 대한 접근을 제공하거나 가상 IP 수준에서 직접 제어하는 포드에 접근할 수 있는 서비스를 제공할 수 있다. 기본 쿠버네티스 서비스는 편리한 엔드포인트를 통해 노출된다. 서비스는 OSI 7계층의 3계층(TCP/UDP)에서 동작한다. 쿠버네티스 1.2 부터 HTTP 객체에 접근할 수 있는 *Ingress* 객체가 추가됐고 이후 더 많은 기능이 추가됐다. 서비스는 DNS 또는 환경 변수 두 가지 메커니즘 중 하나를 통해 게시되거나 발견된다. 서비스는 쿠버네티스에 의해 로드밸런싱이 가능하지마, 개발자는 외부 리소스를 사용하거나 특별한 처리가 필요한 서비스의 경우 직접 로드밸런싱을 관리할 수 있다.

### 볼륨

포드의 로컬 저장소는 포드의 소멸과 함께 제거되는 일시적 생명주기를 가진다. 때때로 노드의 컨테이너 사이에 데이터를 교환하기만 하면 되는 경우도 있지만 데이터가 포드보다 오래 보존되거나 포드 간에 데이터를 공유해야 하는 경우도 있다.

볼륨은 이런 요구를 지원한다. 계속 발전 중인 도커는 아직은 제약 사항이 많은 볼륨 개념을 가지고 있다. 쿠버네티스는 별도의 자체 볼륨을 사용한다. 그리고 rkt 같은 컨테이너 유형도 지원해 원칙적으로 도커 볼륨에 의존하지 않는다.

쿠버네티스는 다양한 유형의 볼륨을 지원한다. 현재 많은 볼륨 유형을 직접 지원하지만 **컨테이너 스토리지 인터페이스**를 통해 더 ㅁ낳은 볼륨 유형으로 확장하는 현대적인 접근법이 이루어지고 있다.

### 스테이트풀세트

포드의 생성과 소멸로 인한 데이터 유실이 걱정되면 영구 저장소를 사용할 수 있다. 그러나 때로는 MySQL Galera나 쿠버네티스 같은 분산 데이터 저장소의 관리를 원할 수도 있을 것이다. 이런 클러스터 저장소는 고유하게 식별된 노드에 데이터를 분산시켜 보관한다. 스테이트풀세트(StatefulSet) 관점에서 보면 일반적인 포드와 서비스를 사용해서는 모델링이 불가능하다.

### 시크릿

시크릿은 자격증명과 토큰 같은 민감한 정보를 가진 작은 객체다. 시크릿은 etcd에 저장되며 쿠버네티스 API서버를 통해 접근이 가능하다. 또한 일반적인 데이터 볼륨에 피기백하는 전용 시크릿 볼륨을 사용해 시크릿에 접근하려는 포드에 파일로 마운트될 수 있다. 시크릿은 여러 포드에 마운트될 수 있다. 쿠버네티스는 컴포넌트의 시크릿을 스스로 생성할 수 있으며 사용자는 자신의 시크릿을 생성할 수 있다. 또한 시크릿을 환경변수로 사용하는 방법도 있다. 포드의 시크릿은 더나은 보안을 위해 항상 메모리에 저장된다.

### 이름

쿠버네티스에 있는 각각의 객체는 UID와 이름(name)으로 식별된다. 이름은 API 호출 시 객체를 참조할 때 사용한다. 이름은 253자 이하의 소문자 영숫자, 대시, 점을 포함한 문자열로 구성된다. 객체를 삭제하면 삭제된 객체와 동일한 이름의 또 다른 객체를 만들 수 있지만 UID는 클러스터 생명주기 동안 유일해야 한다. 쿠버네티스는 UID를 자동으로 생성하기 때문에 사용자는 UID 생성을 고민하지 않아도 된다.

### 네임스페이스

네임스페이스(namespace)는 가상 클러스터다. 사용자는 네임스페이스로 분리된 여러 가상 클러스터들을 가진 단일 물리 클러스터를 가질 수 있다. 각 가상 클러스터는 다른 가상 클러스터와 완전히 분리되어 있으며 공용 인터페이스를 통해서만 통신할 수 있다. 노드 객체와 영구 볼륨은 네임스페이스에 상주하지 않는다. 동일 노드에서 실행을 위해 쿠버네티스는 다른 네임스페이스의 포드를 스케줄링할 수 있다. 마찬가지로 서로 다른 네임스페이스에 있는 포드는 동일한 영구 저장소를 사용할 수 있다. 네임스페이스를 사용할 때는 실제 클러스터 리소스가 적절하게 접근하고 분배할 수 있게 네트워크 정책과 리소스 할당을 고려해야 한다.