# 1장: 쿠버네티스 아키텍쳐 이해

**쿠버네티스**: 컨테이너 기반 애플리케이션의 배포, 확장, 관리를 조율하는 플랫폼

## 쿠버네티스는 무엇인가

쿠버네티스는 계속 증가하고 있는 엄청난 수의 서비스와 기능이 포함된 플랫폼이다.

핵심 기능은 인프라 전체에 걸쳐 컨테이너에서 작업부하를 스케줄할 수 있는 능력이다.

- 스토리지 시스템 마운트

- 보안 배포

- 애플리케이션 상태 확인

- 애플리케이션 인스턴스 복제

- 수평적 포드 자동 스케일링

- 이름 지정과 검색

- 로드밸런싱(부하 균영 조정)

- 롤링 업데이트

- 리소스 모니터링

- 로그 액세스 및 수집

- 애플리케이션 디버깅

- 인증과 권한 부여

<br></br>

## 쿠버네티스가 아닌 것은 무엇인가

쿠버네티스는 **PaaS**(Platform as a Service)는 아니다. 원하는 서비스를 만들 때 시스템의 중요 사항을 일일이 구성할 필요가 없다. 대신 이런 사항을 쿠버네티스 위에 구축된 시스템이나 사용자에게 남겨 둔다. 예를 들면 다음과 같다.

- 쿠버네티스는 특정한 애플리케이션 유형이나 프레임워크를 요구하지 않는다

- 쿠버네티스는 특정한 프로그래밍 언어를 요구하지 않는다

- 쿠버네티스는 데이터베이스 또는 메시지 대기열을 제공하지 않는다

- 쿠버네티스는 앱과 서비스를 구분하지 않는다

- 쿠버네티스는 클릭 투 배포 서비스 시장을 가지고 있지 않다

- 쿠버네티스는 사용자가 자체 로깅과 모니터링, 경보 시스템을 선택할 수 있다

<br></br>

## 컨테이너 오케스트레이션 이해

쿠버네티스의 주요 임무는 컨테이너 오케스트레이션이다. 즉, 다양한 작업을 실행하는 모든 컨테이너가 물리 장치나 가상 머신에서 실행되도록 예약돼 있는지 확인한다. 그리고 배포 환경과 클러스터 설정의 제약 사항에 따라 컨테이너가 효율적으로 패키징돼야 한다. 또한 쿠버네티스는 실행 중인 모든 컨테이너를 모니터링하여 중지되거나 응답이 없거나 상태가 불량한 컨테이너를 교체한다.

### 컨테이너의 장점

- 애자일(민첩한) 애플리케이션 생성과 배포

- 지속적인 개발과 통합 및 배포

- 개발 및 운영 분리의 관심사

- 개발과 테스트, 운영 전반에 걸친 환경 일관성

- 클라우드와 OS 배포 이식성

- 애플리케이션 중심의 관리

- 느슨하게 결합하고 분산되며 탄력적이고 자율적인 마이크로서비스의 리소스 격리

- 리소스 활용성

<br></br>

## 쿠버네티스 개념

### 클러스터

클러스터는 쿠버네티스가 시스템을 구성하는 다양한 업무를 실행하는 데 사용하는 다수의 컴퓨터, 스토리지, 네트워크 리소스의 집합이다. 여러 개의 클러스터로 전체 시스템을 구성할 수 있다.

### 노드

노드는 단일 호스트로 물리 머신이거나 가상 머신일 수 있다. 노드는 포드를 실행시킨다. 각 쿠버네티스 노드는 kubelet과 kube proxy 등 여러 쿠버네티스 컴포넌트를 실행한다. 각각의 노드는 쿠버네티스 마스터에 의해 관리된다.

### 마스터

마스터는 쿠버네티스의 컨트롤 플레인으로 클러스터를 관리한다. 마스터는 API 서버, 스케줄러, 컨트롤러 매니저 등 여러 컴포넌트로 구성된다. 마스터는 클러스터 수준의 포드 스케줄링과 이벤트 처리를 담당한다. 모든 마스터 컴포넌트는 단일 호스트에 설정하는 것이 일반적이나, 고가용성 시나리오나 대규모 클러스터를 고려할 경우에는 마스터 이중화(redundancy)를 요구한다

### 포드

포드는 쿠버네티스의 작업 단위다. 포드에는 한 개 또는 여러 개의 컨테이너가 들어 있다. 동일한 시스템에서 실행되는 여러 포드는 항상 함께 스케줄링된다. 포드의 컨테이너들은 모두 동일한 IP 주소와 포트 공간을 가지고 있으며 로컬호스트를 사용하거나 표준 IPC를 사용해 서로 통신한다. 또는 포드의 모든 컨테이너는 포드를 호스팅하는 노드에 있는 공유 로컬 저장소에 접근이 가능하며, 공유 저장소는 각 컨테이너로 마운트될 수 있다.

포드 개념의 장점으로는:

- **투명성**: 포드 내부의 컨테이너를 인프라에 표시하면 인프라가 프로세스 관리와 리소스 모니터링 서비스를 컨테이너에 제공할 수 있다

- **소프트웨어 종속성 분리**: 개별 컨테이너의 버전 관리, 재구축, 재배포를 독립적으로 수행할 수 있다

- **사용 편의성**: 사용자는 자신의 프로세스 매니저를 실행할 필요가 없으며 시그널과 종료 코드 전파 등을 걱정하지 않아도 된다

- **효율성**: 인프라에 더 많은 역할을 부여해 컨테이너를 더 경량화할 수 있는 장점이 있다

포드는 서로 의존하며 목적을 달성하기 위해 동일한 호스트에서 협업해야 하는 밀접한 연관이 있는 컨테이너 그룹을 관리하기 위한 훌륭한 솔류션을 제공한다. 포드는 필요에 따라 버릴 수 있고 교체할 수 있는 일시적인 요소이며, 포드 저장소는 해당 포드와 함께 소멸된다. 각 포드는 **고유한 ID**를 가지며 필요에 따라 ID를 구별할 수 있다.

### 라벨

라벨은 키/값(key-value)쌍의 객체 집합이며 주로 포드를 그룹화할 때 사용한다. 라벨은 복제 컨트롤러, 복제 세트, 동적 개체 그룹에서 동작하고 그룹 구성원을 식별하는 서비스와 같은 여러 다른 관점에서 중요하다. 객체와 라벨 사이에는 N X N 관계가 있다. 따라서 각 개체는 여러 개의 라벨을 가질 수 있고 각 라벨도 여러 객체에 적용될 수 있다. 라벨 설계에는 제한 사항이 있다. 객체의 라벨은 반드시 고유한 키를 가져야 하며, 라벨 키는 반드시 엄격한 구문을 따라야 한다. 구문은 접두사와 이름, 두 부분으로 구성되며 접두사는 선택 사항이다. 접두사는 슬래시(/)로 이름과 구분되며 유효한 DNS 하위 도메인으로 구성되고 최대 253자까지 허용된다. 이름은 필수이며 최대 63자까지 허용된다. 이름은 문자나 숫자(a-zA-Z0-9)로 시작하고 끝나야 하며, 문자, 숫자, 점, 대시, 밑줄만 사용 가능하다. 값 항목에도 이름과 동일한 제약 사항이 적용된다. 라벨은 객체를 식별하는 데 사용하며 객체에 임의의 메타데이터를 연결하지 않는다.

### 애노테이션

애노테이션(Annotation)을 사용하면 임의의 메타데이터를 쿠버네티스 객체와 연결할 수 있다. 쿠버네티스는 애노테이션을 저장하고 메타데이터를 사용할 수 있게 한다. 라벨과 애노테이션의 차이는 애노테이션은 허용 가능한 문자나 크기에 엄격한 제한이 없다는 것이다.

### 라벨 설렉터

라벨 설렉터(Label selector)는 라벨을 기반으로 객체를 선택하며, 동등 기반 설렉터와 집합 기반 설렉터가 있다. 동등 기반(equality-based) 설렉터는 키 이름과 값을 지정하며 값에 따라 같음이나 다름을 나타내는 =(또는 ==)와 != 두 연산자를 사용한다.

```python
role = webserver
```

이 경우 라벨 키와 값을 가진 모든 객체가 선택된다.

라벨 설렉터는 복수 조건을 쉼표(,)로 구분할 수 있다.

```python
role = webserver, application != foo
```

집합 기반(set-based) 설렉터는 기능을 확장해 다양한 값을 기반으로 하여 객체를 선택한다.

```python
role in (webserver, backend)
```

### 복제 컨트롤러와 복제 세트

복제 컨트롤러(Replication controller)와 복제 세트(replica set)는 라벨 설렉터로 식별된 포드 그룹을 관리하고 특정 수만큼 항상 실행 중인지 확인한다. 복제 컨트롤러는 이름의 동일 여부로 구성원을 확인하는 반면에, 복제 세트는 집합 기반 선택을 사용한다는 것이 두 개념의 주요 차이점이다.

쿠버네티스는 복제 컨트롤러나 복제 세트에서 지정한 수의 포드가 항상 실행되도록 보장한다. 어떤 문제가 발생해 호스팅 노드나 포드의 수가 일정 수준 이하로 내려가면 쿠버테니스는 새로운 인스턴스를 시작한다. 사용자가 수동으로 새로운 포드를 시작해 지정한 수를 초과하면 복제 컨트롤러는 지정한 수를 유지하기 위해 추가된 포드만큼 기존에 동작 중인 포드를 정지시키므로 주의해야 한다.

복제 컨트롤러는 롤링 업데이트나 일회성 작업 실행과 같은 많은 업무 흐름의 중심에 있다. 쿠버네티스가 진화함에 따라 **배포**(deployment), **잡**(job), **데몬세트**(DaemonSet) 같은 전용 객체(오브젝트)를 통해 여러 작업 흐름들을 직접 지원할 수 있게 됐다.

### 서비스

서비스는 사용자나 다른 서비스에 특정 기능을 노출하는 데 사용된다. 서비스는 특정 라벨을 가지고 있는 포드를 선택해 서비스로 묶을 수 있다. 또한 외부 리소스에 대한 접근을 제공하거나 가상 IP 수준에서 직접 제어하는 포드에 접근할 수 있는 서비스를 제공할 수 있다. 기본 쿠버네티스 서비스는 편리한 엔드포인트를 통해 노출된다. 서비스는 OSI 7계층의 3계층(TCP/UDP)에서 동작한다. 쿠버네티스 1.2 부터 HTTP 객체에 접근할 수 있는 *Ingress* 객체가 추가됐고 이후 더 많은 기능이 추가됐다. 서비스는 DNS 또는 환경 변수 두 가지 메커니즘 중 하나를 통해 게시되거나 발견된다. 서비스는 쿠버네티스에 의해 로드밸런싱이 가능하지마, 개발자는 외부 리소스를 사용하거나 특별한 처리가 필요한 서비스의 경우 직접 로드밸런싱을 관리할 수 있다.

### 볼륨

포드의 로컬 저장소는 포드의 소멸과 함께 제거되는 일시적 생명주기를 가진다. 때때로 노드의 컨테이너 사이에 데이터를 교환하기만 하면 되는 경우도 있지만 데이터가 포드보다 오래 보존되거나 포드 간에 데이터를 공유해야 하는 경우도 있다.

볼륨은 이런 요구를 지원한다. 계속 발전 중인 도커는 아직은 제약 사항이 많은 볼륨 개념을 가지고 있다. 쿠버네티스는 별도의 자체 볼륨을 사용한다. 그리고 rkt 같은 컨테이너 유형도 지원해 원칙적으로 도커 볼륨에 의존하지 않는다.

쿠버네티스는 다양한 유형의 볼륨을 지원한다. 현재 많은 볼륨 유형을 직접 지원하지만 **컨테이너 스토리지 인터페이스**를 통해 더 ㅁ낳은 볼륨 유형으로 확장하는 현대적인 접근법이 이루어지고 있다.

### 스테이트풀세트

포드의 생성과 소멸로 인한 데이터 유실이 걱정되면 영구 저장소를 사용할 수 있다. 그러나 때로는 MySQL Galera나 쿠버네티스 같은 분산 데이터 저장소의 관리를 원할 수도 있을 것이다. 이런 클러스터 저장소는 고유하게 식별된 노드에 데이터를 분산시켜 보관한다. 스테이트풀세트(StatefulSet) 관점에서 보면 일반적인 포드와 서비스를 사용해서는 모델링이 불가능하다.

### 시크릿

시크릿은 자격증명과 토큰 같은 민감한 정보를 가진 작은 객체다. 시크릿은 etcd에 저장되며 쿠버네티스 API서버를 통해 접근이 가능하다. 또한 일반적인 데이터 볼륨에 피기백하는 전용 시크릿 볼륨을 사용해 시크릿에 접근하려는 포드에 파일로 마운트될 수 있다. 시크릿은 여러 포드에 마운트될 수 있다. 쿠버네티스는 컴포넌트의 시크릿을 스스로 생성할 수 있으며 사용자는 자신의 시크릿을 생성할 수 있다. 또한 시크릿을 환경변수로 사용하는 방법도 있다. 포드의 시크릿은 더나은 보안을 위해 항상 메모리에 저장된다.

### 이름

쿠버네티스에 있는 각각의 객체는 UID와 이름(name)으로 식별된다. 이름은 API 호출 시 객체를 참조할 때 사용한다. 이름은 253자 이하의 소문자 영숫자, 대시, 점을 포함한 문자열로 구성된다. 객체를 삭제하면 삭제된 객체와 동일한 이름의 또 다른 객체를 만들 수 있지만 UID는 클러스터 생명주기 동안 유일해야 한다. 쿠버네티스는 UID를 자동으로 생성하기 때문에 사용자는 UID 생성을 고민하지 않아도 된다.

### 네임스페이스

네임스페이스(namespace)는 가상 클러스터다. 사용자는 네임스페이스로 분리된 여러 가상 클러스터들을 가진 단일 물리 클러스터를 가질 수 있다. 각 가상 클러스터는 다른 가상 클러스터와 완전히 분리되어 있으며 공용 인터페이스를 통해서만 통신할 수 있다. 노드 객체와 영구 볼륨은 네임스페이스에 상주하지 않는다. 동일 노드에서 실행을 위해 쿠버네티스는 다른 네임스페이스의 포드를 스케줄링할 수 있다. 마찬가지로 서로 다른 네임스페이스에 있는 포드는 동일한 영구 저장소를 사용할 수 있다. 네임스페이스를 사용할 때는 실제 클러스터 리소스가 적절하게 접근하고 분배할 수 있게 네트워크 정책과 리소스 할당을 고려해야 한다.

<br></br>

## 쿠버네티스 구조 심층 탐구

쿠버네티스는 광범위한 환경에서 클라우드 공급자의 분산 환경 시스템을 간단하게 오케스트레이션, 배포, 관리하는 매우 큰 목표를 가지고 있다. 이런 서비스 제공은 어려운 작업으로, 쿠버네티스는 수정처럼 명료하고 높은 수준의 디자인을 따르고, 확장성과 결합성을 촉진하는 잘 설계된 아키텍쳐를 통해 이를 제공하고 있다.

### 분산 시스템 디자인 패턴

쿠버네티스는 단순한 관리 시스템이 아니다. 쿠버네티스는 모범 사례의 지원과 활용으로 개발자와 매니저에게 높은 수준의 서비스를 제공한다. 이것을 위한 디자인 패턴 중 일부를 살펴보자.

#### 사이드카 패턴

사이드카 패턴은 포드에 있는 다른 컨테이너를 메인 어플리케이션 컨테이너에 함께 배치하는 것이다. 애플리케이션 컨테이너는 사이드카 컨테이너가 추가된 것을 인지하지 못한 채 자신의 역할을 수행한다. 중앙 집중식 로깅 에이전트(central logging agent)가 좋은 예다. 메인 컨테이너는 표준 출력(stdout)에 로그를 기록한다. 하지만 사이드카 컨테이너는 모든 로그를 중앙 집중식 로깅 서비스로 전송하고 전체로 시스템과의 로그를 집계한다. 메인 애플리케이션에 중앙 집중식 로그의 기록을 위해 사이드카 컨테이너를 함께 사용하면 큰 장점이 있다. 대표적인 장점은 중앙 집중식 로그 수집 환경으로 발생하는 애플리케이션의 부담을 해소하는 것이다. 중앙 집중식 로길 정책을 갱신하거나 완전히 새로운 공급자로 전환할 경우 사이드카 컨테이너만 업데이트하고 배포하면 된다. 애플리케이션 컨테이너에는 변경이 없으므로 실수로 애플리케이션이 중단되는 일도 없을 것이다.

#### 앰버서더 패턴

앰버서더 패턴은 원격 서비스가 마치 로컬인 것처럼 운영되도록 일부 정책을 시행하는 것이다. 쓰기 작업용 마스터 하나와 읽기 작업용 복제본 다수로 구성된 레디스(Redis) 클러스터가 앰버서더 패턴의 좋은 예다. 로컬 앰버서더 컨테이너는 프록시 역할을 하며 로컬호스트의 메인 애플리케이션 컨테이너에 레디스를 노출할 수 있다. 메인 애플리케이션 컨테이너는 localhost:6379(Redis의 기본 포트)에 있는 레디스에 간단히 연결되지만 실제로 동일한 포드에서 동작 중인 앰버서더에 연결된다. 앰버서더는 요청을 필터링하고, 실제 레디스 마스터에게 쓰기 요청을 보내고, 읽기 복제본 중 하나로 읽기 요청을 전송한다. 사이드카 패턴과 같이 메인 애플리케이션은 어떤 일이 일어나고 있는지 알지 못한다. 이것은 실제 로컬 레디스 환경에서 테스트할 경우 많은 도움이 된다. 또한 레디스 클러스터 구성의 변경이 있는 경우 앰버서더만 수정하면 되며 메인 애플리케이션은 아무런 영향을 받지 않는다.

#### 어댑터 패턴

어댑터 패턴은 메인 애플리케이션 컨테이너의 출력을 표준화하는 것이다. 점진적으로 배포되는 서비스를 가정해보자. 이전 버전과 일치하지 않는 형식의 출력이 발생하고 그 출력을 사용하는 다른 서비스나 애플리케이션은 아직 업그레이드되지 않은 경우를 가정하자. 이 경우 어댑터 컨테이너는 새로운 애플리케이션 컨테이너와 함께 동일한 포드에 배포될 수 있으며 해당 출력을 사용하는 다른 서비스나 애플리케이션이 업그레이드 될 때 까지 이전 버전에 맞게 출력을 변경할 수 있다. 어댑터 컨테이너는 메인 어플리케이션 컨테이너와 파일시스템을 공유하기 때문에 로컬 파일시스템의 감시가 가능하며 새로운 애플리케이션이 무언가 쓰기 작업을 할 때마다 이를 즉시 변경한다.

#### 다중 노드 패턴

모든 단일 노드 패턴은 포드를 통해 쿠버네티스가 직접 지원한다. 반면, 리더 선출, 작업 큐, 분산 수집 같은 다중 노드 패턴은 쿠버테니스의 직접적인 지원 없이 표준 인터페이스를 사용해 포드를 구성한 쿠버네티스에서 실행 가능한 접근 방식이다.

<br></br>

## 쿠버네티스 API

시스템과 시스템 기능이 제공하는 것을 이해하려면 시스템의 AIP에 많은 관심을 가져야 한다. 사용자는 API를 통해 시스템이 제공하는 기능을 포괄적으로 히해할 수 있다. 쿠버네티스는 다양한 목적과 대상을 위해 몇 가지 REST API 집합을 공개한다. 일부 API는 주로 도구로 사용되며 일부 API는 개발자가 직접 사용할 수 있다. API가 지속적으로 개발되고 있다는 것은 매우 중요한 포인트다. 쿠버네티스 개발자는 기존 객체에 새로운 객체와 필드를 추가해 API를 확장하고, 기존 객체와 필드의 이름 바꾸기나 삭제를 피함으로써 API 관리가 가능하도록 유지한다. 또한 모든 API 엔드포인트의 버전은 관리되며 알파나 베타 표기법을 사용해 관리하는 경우가 많다. 다음은 그 예다.

```bash
/api/v1
/api/v2alpha1
```

개발자는 kubectl cli 또는 클라이언트 라이브러리를 사용하거나 직접 REST API 호출을 통해 API에 접근할 수 있다. API 사용에는 정교한 인증과 권한 부여 메커니즘이 있다. 올바른 사용 권한이 있으면 다양한 쿠버네티스 객체를 나열하고, 보고, 생성하고, 업데이트, 삭제할 수 있다. API를 살짝 엿보면 API를 탐색하는 가장 좋은 방법은 API 그룹을 이용하는 것이다. 일부 API 그룹은 기본적으로 활성화되어 있다. 일부 그룹은 플래그를 이용해 활성화 또는 비활성화할 수 있다. 예를 들어 배치 V1 그룹을 비활성화하고 배치 V2 알파 그룹을 활성화하려면 다음과 같이 API 서버를 실행할 때 `--runtime-config` 플래그를 설정할 수 있다.

```bash
--runtime-config=batch/v1=false,batch/v2alpha=true
```

핵심 리소스 외에 다음 리소스가 기본적으로 활성화된다.

- 데몬셋(DaemonSets)

- 배포(Deployments)

- 수평적 포드 자동 스케일러(HorizontalPodAutoscalers)

- 인그레스(Ingress)

- 잡(Jobs)

- 복제 세트(ReplicaSets)

### 리소스 카테고리

API 그룹 외에도 사용 가능한 API의 또 다른 유용한 분류는 기능이다. 쿠버네티스 API는 쿠버네티스의 주요 API로 매우 방대하며, 카테고리로 분류하면 필요한 것을 찾을 때 많은 도움이 된다.

- 작업부하(Workloads): 클러스터에서 컨테이너를 관리하고 실행하는 데 사용하는 객체다

- 검색과 로드밸런싱(Discovery and load balancing): 작업부하를 외부에서 접근 가능하고 로드밸런스된 서비스로 전 세계에 노출하는 데 사용하는 객체다

- 구성과 스토리지(Config and storage): 애플리케이션 초기화와 구성 및 컨테이너 외부에 있는 데이터를 유지하는 데 사용되는 객체다

- 클러스터(Cluster): 클러스터 자체 구성 방법을 정의하는 객체다. 일반적으로 클러스터 운영자만 사용한다

- 메타데이터(Metadata): 작업부하를 조정하기 위한 수평적 포드 자동 스케일러처럼 클러스터 내 다른 리소스의 동작을 구성하는 데 사용하는 객체다

#### 워크로드 API

워크로드 API에는 다음과 같은 리소스가 들어있다

- 컨테이너(Container): 코어

- 크론잡(CronJob): 배치

- 데몬셋(DaemonSet): 앱

- 배포(Deployment): 앱

- 잡(Job): 배치

- 포드(Pod): 코어

- 복제 세트(ReplicaSet): 앱

- 복제 컨트롤러(ReplicationController): 코어

- 스테이트풀세트(StatefulSet): 앱

컨테이너는 포드를 사용해 컨트롤러에 의해 생성된다. 포드는 컨테이너를 실행하고 공유 또는 영구 스토리지 볼륨과 같은 환경 종속성을 제공하며, 컨테이너에 주입된 구성이나 비밀 데이터를 제공한다.

다음은 가장 일반적인 작업 중 하나인 REST API로 모든 포드의 목록을 가져오는 작업을 자세히 설명한다.

```bash
GET /api/v1/pods
```

다양한 쿼리 매개변수를 사용할 수 있으며 모두 선택 사항이다.

- pretty: 참이면 보기 좋은 형태로 출력

- labelSelector: 라벨에 따라 반환된 객체 목록 제한하는 선택자

- watch: 참이면 변경을 감시하고 이벤트(추가, 업데이트, 제거) 스트림을 반환

- resourceVersion: 특정 버전 이후 발생한 이벤트 반환

- timeoutSeconds: list나 watch 호출 시 타임아웃 설정값

#### 검색과 로드밸런싱

기본적으로 워크로드는 클러스터 내에서만 엑세스할 수 있으며 LoadBalancer 또는 NodePort 서비스를 사용해 외부에 노출돼야 한다. 개발 중에 내부적으로 접근할 수 있는 워크로드는 `kubectl proxy` 명령을 사용해 API 마스터를 거쳐 프록시를 거쳐 액세스 할 수 있다.

- 엔드포인트(endpoint): 코어

- 인그레스(ingress): 확장 프로그램

- 서비스(service): 코어

#### 구성과 스토리지

재배포하지 않는 동적 구성은 쿠버네티스의 기반이며 쿠버네티스 클러스터에서 복잡한 분산 애플리케이션을 실행한다.

- ConfigMap: 코어

- Secret: 코어

- PersistentVolumeClaim: 코어

- StorageClass: 스토리지

- VolumeAttachment: 스토리지

#### 메타데이터

메타데이터 리소스는 일반적으로 구성하는 리소스의 하위 그룹으로 포함된다. 예를 들어 제한 범위는 포드 구성의 일부가 된다. 대부분의 경우 이런 객체와 직접 상호작용하지 않는다.

#### 클러스터

클러스터 범주의 리소스는 개발자가 아니라 클러스터 운영자가 사용하도록 설계됐다.

- Namespace: 코어

- Node: 코어

- PersistentVolume: 코어

- ResourceQuota: 코어

- ClusterRole: Rbac

- NetworkPolicy: 네트워킹

<br></br>

## 쿠버네티스 컴포넌트

쿠버네티스 클러스터의 컴포넌트는 클러스터를 제어하는 목적을 가진 여러 마스터 컴포넌트와 각 클러스터 노드에서 실행되는 노드 컴포넌트로 구성되어 있다.

### 마스터 컴포넌트

마스터 컴포넌트는 일반적으로 하나의 노드에서 동작하지만 고가용성 환경이나 대규모 클러스터에서는 여러 노드에 분산된 형태로 가능하다

#### API 서버

kube API 서버는 쿠버네티스 REST API를 공개하다. 상태 비저장이고 모든 데이터를 etcd 클러스터에 저장하므로 쉽게 수평 확장이 가능하다. API 서버는 쿠버네티스 제어 플레인(control plane)을 구체화한 것이다

##### etcd

etcd는 높은 신뢰 기반의 분산 데이터 저장소다. 쿠버네티스는 이것을 이용해 전체 클러스터의 상태를 저장한다. 규모가 작고 일시적인 클러스터의 경우에는 etcd 단일 인스턴스가 다른 마스터 컴포넌트와 함께 동일한 노드에서 동작할 수 있다. 하지만 대규모 클러스터의 경우 일반적으로 이중화와 고가용성을 위해 3개에서 많으면 5개의 etcd 클러스터를 갖기도 한다

##### kube 컨트롤러 매니저

kube 컨트롤러 매니터는 다양한 매니저를 하나의 바이너리로 통합한 도구다. 따라서 컨트롤러 매니저에는 복제 컨틀롤러, 포드 컨트롤러, 서비스 컨트롤러, 엔드포인트 컨트롤러 등이 포함된다. 컨트롤러 매니저는 API를 사용해 클러스터의 상태를 감시하고, 클러스터를 원하는 상태로 조정한다.

##### 클라우드 컨트롤러 매니저

클라우드 공급자는 쿠버네티스를 통해 클라우드에서 실행될 때 노드, 라우트, 서비스, 볼륨을 관리하기 위해 플랫폼을 통합할 수 있다. 클라우드 공급자 코드는 쿠버네티스 코드와 상호작용한다. 이것은 Kube 컨트롤러 매니저의 일부 기능을 대체한다. 클라우드 컨트롤러 매니저와 함께 쿠버네티스를 실행할 때는 Kube 컨트롤러 매니저 플래그인 `--cloud-provier`를 `external`로 설정해야 한다. 이렇게 하면 클라우드 컨트롤러 매니저가 수행하는 제어 루프가 비활성화된다.

다음은 cloudprovider 패키지의 기본 인터페이스다.

```go
package cloudprovider
import (
    "errors"
    "fmt"
    "strings"
    "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/types"
    "k8s.io/client-go/informers"
    "k8s.kubernetes/pkg/controller"
)

// 인터페이스는 클라우드 공급자를 위해 추상적이며 플러그 형태의 인터페이스이다
type Interface interface {
    Initialize(clientBuilder controller.ControllerClientBuilder)
    LoadBalancer() (LoadBalanacer, bool)
    Instances() (Instances, bool)
    Zones() (Zones, bool)
    Clusters() (Clusters, bool)
    Routes() (Routes, bool)
    ProviderNames() string
    HasClusterID() bool

}
```

대부분의 메소드는 자신의 메소드와 함께 다른 인터페이스를 반환한다. 예를 들어 다음은 LoadBalancer 인터페이스다

```go
type LoadBalancer interface {
    GetLoadBalancer(clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error)
    EnsureLoadBalanacer(clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error)
    UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error
    EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error
}
```

##### kube 스케줄러

kube 스케줄러는 노드에 포드를 스케줄링하는 역할을 담당한다. 이것은 다음과 같은 여러 상호작용 요인을 고려해야 하므로 매우 복잡한 작업이다.

- 리소스 요구 사항

- 서비스 요구 사항

- 하드웨어와 소프트웨어 정책 제약 사항

- 노드 친화성과 비친화성 사양

- 포드 친화성과 비친화성 사양

- taint와 toleration

- 데이터 지역성

- 마감성

기본 Kube 스케줄러에서 다루지 않는 특별한 스케줄링 로직이 필요한 경우, 자신만의 스케줄러로 대체할 수 있다. 또한 사용자 정의 스케줄러를 기본 스케줄러와 함께 실행하고 사용자 정의 스케줄러가 포드의 일부만 스케줄하도록 할 수도 있다.

##### DNS

쿠버네티스 1.3부터 DNS 서비스는 표준 쿠버네티스 클러스터에 포함됐으며 일반적인 포드로 스케줄링된다. 헤드리스(headless) 서비스를 제외한 모든 서비스는 DNS 이름을 가지며 포드 역시 DNS 이름을 가진다. 이것은 자동 검색에 매우 유용한다.

##### 노드 컴포넌트

클러스터의 노드가 클러스터 마스터 컴포넌트와 상호작용하고 클러스터를 실행하고 업데이트하기 위한 워크로드를 받기 위해서는 몇 가지 관련 컴포넌트가 필요하다.

##### 프록시

kube 프록시는 각 노드에서 저수준의 네트워크 관리 업무를 수행한다. 쿠버네티스 서비스를 지역적으로 반영하고 TCP와 UDP 포워딩을 수행하며 환경 변수나 DNS를 통해 클러스터 IP를 찾는다

##### kubelet

Kubelet은 쿠버네티스를 대표하는 노드라고 할 수 있다. Kubelet은 마스터 컴포넌트와 통신을 수행하며 실행 중인 포드를 관리하고 감독한다.

- API 서버에서 포드 시크릿 다운로드

- 볼륨 마운트

- 포드의 컨테이너 실행(CRI또는 rkt를 통해)

- 노드와 각 포드의 상태 보고

- 실행 중인 컨테이너의 활성 여부 조사

<br></br>

## 지속적인 통합과 배포(CI/CD)

쿠버네티스는 마이크로서비스 기반 애플리케이션을 실행하기에 좋은 플랫폼이다. 그러나 가장 중요한 마지막은 구현의 세부 사항이다. 사용자와 대부분의 개발자는 시스템이 쿠버네티스에 배포되어 있다는 사실을 알지 못한다. 하지만 쿠버네티스는 상황 자체를 바꾸고 어려운 서비스 환경에서 획기적인 솔루션의 역할을 할 것이다.

### CI/CD 파이프라인

CI/CD 파이프라인은 개발자나 운영자가 시스템 코드, 데이터, 구성을 변경하고 테스트하며 이를 운영 환경으로 배포하는 일련의 단계다. 일부 파이프라인은 완전 자동화되어 있으며, 일부는 수동으로 운영되는 반자동화 형태다. 대규모 조직에서는 변경 사항이 자동으로 배포되는 테스트와 준비 환경이 바련돼 있을 수 있다. 그러나 제품을 출시하려면 결국 수작업이 필요하다.
